<% if prologue = @grammar.prologue %>
<%= prologue %>
<% end %>

class <%= @class_name %> < Lrama::Runtime::Parser
<% if parse_param = parse_param_decl %>
  getter <%= parse_param[:name] %> : <%= parse_param[:type] %>
<% end %>
<% @grammar.symbols.sort_by { |sym| sym.number || 0 }.each do |sym| %>
  <%= sym.enum_name %> = <%= sym.number || 0 %>
<% end %>
  YYEMPTY = -2
  YYERROR = <%= @tables.error_symbol %>
  YYEOF = <%= @tables.eof_symbol %>
  YYNTOKENS = <%= @tables.yyntokens %>

  YYPACT = <%= format_array(@tables.yypact) %>
  YYPGOTO = <%= format_array(@tables.yypgoto) %>
  YYDEFACT = <%= format_array(@tables.yydefact) %>
  YYDEFGOTO = <%= format_array(@tables.yydefgoto) %>
  YYTABLE = <%= format_array(@tables.yytable) %>
  YYCHECK = <%= format_array(@tables.yycheck) %>
  YYR1 = <%= format_array(@tables.yyr1) %>
  YYR2 = <%= format_array(@tables.yyr2) %>
  YYLAST = <%= @tables.yylast %>
  YYPACT_NINF = <%= @tables.yypact_ninf %>
  YYTABLE_NINF = <%= @tables.yytable_ninf %>
  YYFINAL = <%= @tables.yyfinal %>
  ERROR_RECOVERY = <%= @error_recovery ? "true" : "false" %>
  HAS_LOCATIONS = <%= @grammar.locations? ? "true" : "false" %>

  def yypact : Array(Int32)
    YYPACT
  end

  def yypgoto : Array(Int32)
    YYPGOTO
  end

  def yydefact : Array(Int32)
    YYDEFACT
  end

  def yydefgoto : Array(Int32)
    YYDEFGOTO
  end

  def yytable : Array(Int32)
    YYTABLE
  end

  def yycheck : Array(Int32)
    YYCHECK
  end

  def yyr1 : Array(Int32)
    YYR1
  end

  def yyr2 : Array(Int32)
    YYR2
  end

  def yylast : Int32
    YYLAST
  end

  def yyntokens : Int32
    YYNTOKENS
  end

  def yypact_ninf : Int32
    YYPACT_NINF
  end

  def yytable_ninf : Int32
    YYTABLE_NINF
  end

  def yyfinal : Int32
    YYFINAL
  end

  def error_symbol : Int32
    YYERROR
  end

  def eof_symbol : Int32
    YYEOF
  end

  def error_recovery? : Bool
    ERROR_RECOVERY
  end

  def has_locations? : Bool
    HAS_LOCATIONS
  end
<% if parse_param = parse_param_decl %>

  def initialize(@<%= parse_param[:name] %> : <%= parse_param[:type] %>, @debug : Bool = false)
    super(@debug)
  end
<% end %>
<% error_cases = error_token_cases %>
<% if !error_cases.empty? %>

  protected def build_repair_token(sym : Int32) : Lrama::Runtime::Token
    case sym
<% error_cases.each do |error_case| %>
<%= error_case %>
<% end %>
    else
      Lrama::Runtime::Token.new(sym)
    end
  end
<% end %>

  def reduce(rule : Int32, values : Array(Lrama::Runtime::Value), locations : Array(Lrama::Runtime::Location?)) : Lrama::Runtime::Value
    stack_base = values.size - yyr2[rule]
    case rule
    when 0
      nil
<% @grammar.rules.each_with_index do |rule, index| %>
<%= reduce_case(rule, index + 1) %>
<% end %>
    else
      nil
    end
  end
end
<% if lexer = lexer_tables %>

class <%= @class_name %>Lexer
  include Lrama::Runtime::Lexer
<% if lex_param = lex_param_decl %>
  getter <%= lex_param[:name] %> : <%= lex_param[:type] %>
<% end %>

  YYLEX_TABLES = <%= format_flat_tables(lexer_tables_flat) %>
  YYLEX_ROW_WIDTH = 256
  YYLEX_ROW_MAP = <%= format_array_of_arrays(lexer_row_maps) %>
  YYLEX_ACCEPTS = <%= format_array_of_arrays(lexer.tables.map(&.accept)) %>
  YYLEX_STATE_COUNT = <%= lexer.states.size %>
  YYLEX_KIND = [<%= lexer_rules.map { |rule| rule.skip? ? 0 : 1 }.join(", ") %>]
  YYLEX_TOKEN = [<%= lexer_rules.map { |rule| rule.token? ? "#{@class_name}::YYSYMBOL_#{rule.name}" : "-1" }.join(", ") %>]
  YYLEX_VALUE_KIND = [<%= lexer_rules.map { |rule| value_kind_index(rule.value_kind) }.join(", ") %>]
  YYLEX_KEYWORD = [<%= lexer_rules.map { |rule| rule.keyword? ? 1 : 0 }.join(", ") %>]
  <% unless lexer_keywords.empty? %>
  YYLEX_USE_KEYWORD_TRIE = <%= use_keyword_trie? ? "true" : "false" %>
  YYLEX_KEYWORD_CHILDREN = <%= format_array_of_arrays(keyword_trie_children) %>
  YYLEX_KEYWORD_TOKEN = <%= format_array(keyword_trie_tokens) %>
  <% end %>
  <% lexer.states.each_with_index do |name, index| %>
  STATE_<%= state_const_name(name) %> = <%= index %>
  <% end %>

  def initialize(@input : String<% if lex_param = lex_param_decl %>, @<%= lex_param[:name] %> : <%= lex_param[:type] %><% end %>)
    @index = 0
    @bytes = @input.to_slice
    @length = @bytes.size
    @state = STATE_INITIAL
  end

  def begin(state : Int32)
    if state < 0 || state >= YYLEX_STATE_COUNT
      raise "Unknown lexer state: #{state}"
    end
    @state = state
  end

  def next_token : Lrama::Runtime::Token
    while @index < @length
      start = @index
      dfa_state = 0
      last_accept = -1
      last_index = start
      table = YYLEX_TABLES[@state]
      row_map = YYLEX_ROW_MAP[@state]
      use_row_map = !row_map.empty?
      accept = YYLEX_ACCEPTS[@state]

      while @index < @length
        byte = @bytes[@index]
        byte_value = byte.to_i
        row_index = use_row_map ? row_map[dfa_state] : dfa_state
        next_state = table[row_index * YYLEX_ROW_WIDTH + byte_value]
        break if next_state < 0
        dfa_state = next_state
        @index += 1
        rule = accept[dfa_state]
        if rule >= 0
          last_accept = rule
          last_index = @index
        end
      end

      if last_accept < 0
        byte = @bytes[start]
        raise "Unexpected character: #{byte}"
      end

      @index = last_index
      if YYLEX_KIND[last_accept] == 0
        next
      end
      return build_token(last_accept, start, last_index - start)
    end

    Lrama::Runtime::Token.new(<%= @class_name %>::YYEOF)
  end

  private def build_token(rule_index : Int32, start : Int32, length : Int32)
    token_id = YYLEX_TOKEN[rule_index]
    <% unless lexer_keywords.empty? %>
    if YYLEX_KEYWORD[rule_index] == 1
      if keyword_id = keyword_token(start, length)
        token_id = keyword_id
        return Lrama::Runtime::Token.new(token_id)
      end
    end
    <% end %>
    value_kind = YYLEX_VALUE_KIND[rule_index]
    if value_kind == 0
      return Lrama::Runtime::Token.new(token_id)
    end
    value =
      case value_kind
      when 1
        parse_int(start, length)
      when 2
        parse_float(start, length)
      when 3
        String.new(@bytes[start, length])
      when 4
        String.new(@bytes[start, length])
      when 5
        @bytes[start, length]
      else
        nil
      end
    Lrama::Runtime::Token.new(token_id, value)
  end

  <% unless lexer_keywords.empty? %>
  private def keyword_token(start : Int32, length : Int32)
    return nil if length == 0
    if YYLEX_USE_KEYWORD_TRIE
      node = 0
      idx = start
      last = start + length
      while idx < last
        byte = @bytes[idx]
        byte_value = byte.to_i
        <% if lexer_keywords_case_insensitive? %>
        if byte >= 97_u8 && byte <= 122_u8
          byte -= 32_u8
          byte_value = byte.to_i
        end
        <% end %>
        children = YYLEX_KEYWORD_CHILDREN[node]
        next_node = -1
        i = 0
        while i < children.size
          if children[i] == byte_value
            next_node = children[i + 1]
            break
          end
          i += 2
        end
        return nil if next_node < 0
        node = next_node
        idx += 1
      end
      token = YYLEX_KEYWORD_TOKEN[node]
      return token >= 0 ? token : nil
    end
    <% unless lexer_keywords.empty? %>
<%= keyword_case_lines %>
    <% end %>
    nil
  end
  <% unless lexer_keywords.empty? %>
  private def keyword_match?(start : Int32, length : Int32, keyword : String)
    return false unless length == keyword.bytesize
    bytes = keyword.to_slice
    i = 0
    while i < length
      byte = @bytes[start + i]
      <% if lexer_keywords_case_insensitive? %>
      if byte >= 97_u8 && byte <= 122_u8
        byte -= 32_u8
      end
      <% end %>
      return false if byte != bytes[i]
      i += 1
    end
    true
  end
  <% end %>
  <% end %>

  private def parse_int(start : Int32, length : Int32)
    value = 0
    i = 0
    while i < length
      byte = @bytes[start + i]
      value = value * 10 + (byte - 48)
      i += 1
    end
    value
  end

  private def parse_float(start : Int32, length : Int32)
    value = 0.0
    i = 0
    while i < length
      byte = @bytes[start + i]
      break if byte == 46
      value = value * 10.0 + (byte - 48)
      i += 1
    end
    return value if i >= length
    i += 1
    scale = 0.1
    while i < length
      byte = @bytes[start + i]
      value += (byte - 48) * scale
      scale *= 0.1
      i += 1
    end
    value
  end
end

class <%= @class_name %>
  def self.run(io : IO = STDIN)
    input = io.gets_to_end
    parser = new
    parser.parse(<%= @class_name %>Lexer.new(input))
    parser
  end
end
<% end %>
<% if epilogue = @grammar.epilogue %>

<%= epilogue %>
<% end %>

<% if prologue = @grammar.prologue %>
<%= prologue %>
<% end %>

class <%= @class_name %> < Lrama::Runtime::Parser
<% @grammar.symbols.sort_by { |sym| sym.number || 0 }.each do |sym| %>
  <%= sym.enum_name %> = <%= sym.number || 0 %>
<% end %>
  YYEMPTY = -2
  YYERROR = <%= @tables.error_symbol %>
  YYEOF = <%= @tables.eof_symbol %>
  YYNTOKENS = <%= @tables.yyntokens %>

  YYPACT = <%= format_array(@tables.yypact) %>
  YYPGOTO = <%= format_array(@tables.yypgoto) %>
  YYDEFACT = <%= format_array(@tables.yydefact) %>
  YYDEFGOTO = <%= format_array(@tables.yydefgoto) %>
  YYTABLE = <%= format_array(@tables.yytable) %>
  YYCHECK = <%= format_array(@tables.yycheck) %>
  YYR1 = <%= format_array(@tables.yyr1) %>
  YYR2 = <%= format_array(@tables.yyr2) %>
  YYLAST = <%= @tables.yylast %>
  YYPACT_NINF = <%= @tables.yypact_ninf %>
  YYTABLE_NINF = <%= @tables.yytable_ninf %>
  YYFINAL = <%= @tables.yyfinal %>
  ERROR_RECOVERY = <%= @error_recovery ? "true" : "false" %>

  def yypact : Array(Int32)
    YYPACT
  end

  def yypgoto : Array(Int32)
    YYPGOTO
  end

  def yydefact : Array(Int32)
    YYDEFACT
  end

  def yydefgoto : Array(Int32)
    YYDEFGOTO
  end

  def yytable : Array(Int32)
    YYTABLE
  end

  def yycheck : Array(Int32)
    YYCHECK
  end

  def yyr1 : Array(Int32)
    YYR1
  end

  def yyr2 : Array(Int32)
    YYR2
  end

  def yylast : Int32
    YYLAST
  end

  def yyntokens : Int32
    YYNTOKENS
  end

  def yypact_ninf : Int32
    YYPACT_NINF
  end

  def yytable_ninf : Int32
    YYTABLE_NINF
  end

  def yyfinal : Int32
    YYFINAL
  end

  def error_symbol : Int32
    YYERROR
  end

  def eof_symbol : Int32
    YYEOF
  end

  def error_recovery? : Bool
    ERROR_RECOVERY
  end

  def reduce(rule : Int32, values : Array(Lrama::Runtime::Value), locations : Array(Lrama::Runtime::Location?)) : Lrama::Runtime::Value
    case rule
    when 0
      nil
<% @grammar.rules.each_with_index do |rule, index| %>
<%= reduce_case(rule, index + 1) %>
<% end %>
    else
      nil
    end
  end
end
<% if lexer = lexer_tables %>

class <%= @class_name %>Lexer
  include Lrama::Runtime::Lexer

  YYLEX_TABLES = <%= format_flat_tables(lexer.tables.map { |table| flatten_table(table.transitions) }) %>
  YYLEX_ROW_WIDTH = 256
  YYLEX_ACCEPTS = <%= format_array_of_arrays(lexer.tables.map(&.accept)) %>
  YYLEX_STATE_COUNT = <%= lexer.states.size %>
  YYLEX_KIND = [<%= lexer_rules.map { |rule| rule.skip? ? 0 : 1 }.join(", ") %>]
  YYLEX_TOKEN = [<%= lexer_rules.map { |rule| rule.token? ? "#{@class_name}::YYSYMBOL_#{rule.name}" : "-1" }.join(", ") %>]
  YYLEX_VALUE_KIND = [<%= lexer_rules.map { |rule| value_kind_index(rule.value_kind) }.join(", ") %>]
  YYLEX_KEYWORD = [<%= lexer_rules.map { |rule| rule.keyword? ? 1 : 0 }.join(", ") %>]
  <% unless lexer_keywords.empty? %>
  YYLEX_KEYWORD_MAP = {<%= keyword_map_lines %>}
  <% end %>
  <% lexer.states.each_with_index do |name, index| %>
  STATE_<%= state_const_name(name) %> = <%= index %>
  <% end %>

  def initialize(@input : String)
    @index = 0
    @bytes = @input.to_slice
    @length = @bytes.size
    @state = STATE_INITIAL
  end

  def begin(state : Int32)
    if state < 0 || state >= YYLEX_STATE_COUNT
      raise "Unknown lexer state: #{state}"
    end
    @state = state
  end

  def next_token : Lrama::Runtime::Token
    while @index < @length
      start = @index
      dfa_state = 0
      last_accept = -1
      last_index = start
      table = YYLEX_TABLES[@state]
      accept = YYLEX_ACCEPTS[@state]

      while @index < @length
        byte = @bytes[@index]
        next_state = table[dfa_state * YYLEX_ROW_WIDTH + byte]
        break if next_state < 0
        dfa_state = next_state
        @index += 1
        rule = accept[dfa_state]
        if rule >= 0
          last_accept = rule
          last_index = @index
        end
      end

      if last_accept < 0
        byte = @bytes[start]
        raise "Unexpected character: #{byte}"
      end

      @index = last_index
      if YYLEX_KIND[last_accept] == 0
        next
      end
      return build_token(last_accept, start, last_index - start)
    end

    Lrama::Runtime::Token.new(<%= @class_name %>::YYEOF)
  end

  private def build_token(rule_index : Int32, start : Int32, length : Int32)
    token_id = YYLEX_TOKEN[rule_index]
    <% unless lexer_keywords.empty? %>
    if YYLEX_KEYWORD[rule_index] == 1
      if keyword_id = keyword_token(start, length)
        token_id = keyword_id
        return Lrama::Runtime::Token.new(token_id)
      end
    end
    <% end %>
    value_kind = YYLEX_VALUE_KIND[rule_index]
    if value_kind == 0
      return Lrama::Runtime::Token.new(token_id)
    end
    value =
      case value_kind
      when 1
        parse_int(start, length)
      when 2
        parse_float(start, length)
      when 3
        String.new(@bytes[start, length])
      when 4
        String.new(@bytes[start, length])
      else
        nil
      end
    Lrama::Runtime::Token.new(token_id, value)
  end

  <% unless lexer_keywords.empty? %>
  private def keyword_token(start : Int32, length : Int32)
    keyword = String.new(@bytes[start, length])
    <% if lexer_keywords_case_insensitive? %>
    keyword = keyword.upcase
    <% end %>
    YYLEX_KEYWORD_MAP[keyword]?
  end
  <% end %>

  private def parse_int(start : Int32, length : Int32)
    value = 0
    i = 0
    while i < length
      byte = @bytes[start + i]
      value = value * 10 + (byte - 48)
      i += 1
    end
    value
  end

  private def parse_float(start : Int32, length : Int32)
    value = 0.0
    i = 0
    while i < length
      byte = @bytes[start + i]
      break if byte == 46
      value = value * 10.0 + (byte - 48)
      i += 1
    end
    return value if i >= length
    i += 1
    scale = 0.1
    while i < length
      byte = @bytes[start + i]
      value += (byte - 48) * scale
      scale *= 0.1
      i += 1
    end
    value
  end
end

class <%= @class_name %>
  def self.run(io : IO = STDIN)
    input = io.gets_to_end
    parser = new
    parser.parse(<%= @class_name %>Lexer.new(input))
    parser
  end
end
<% end %>
<% if epilogue = @grammar.epilogue %>

<%= epilogue %>
<% end %>

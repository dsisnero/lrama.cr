# Samples Parity (Ruby C vs Crystal)

This directory contains Crystal ports of the Ruby lrama samples from `lrama/sample/`.
Each sample is designed to be generated by the Crystal port (`src/lrama/main.cr`) and
run with the generated parser. The original Ruby samples can still be generated into
C via `lrama/exe/lrama` for comparison.

## Generate Ruby C parsers (reference)

These use the Ruby lrama submodule to generate C parsers from the original samples.

```bash
# calc
ruby lrama/exe/lrama -d lrama/sample/calc.y -o temp/calc.c
cc -Wall temp/calc.c -I . -o temp/calc
printf "1\n1+2*3\n(1+2)*3\n" | temp/calc

# json
ruby lrama/exe/lrama -d lrama/sample/json.y -o temp/json.c
cc -Wall temp/json.c -I . -o temp/json
printf '{"foo": 42, "bar": [1, 2, 3], "baz": {"qux": true}}' | temp/json

# sql
ruby lrama/exe/lrama -d lrama/sample/sql.y -o temp/sql.c
cc -Wall temp/sql.c -I . -o temp/sql
printf "SELECT id, name FROM users WHERE age > 18 AND age < 32;\n" | temp/sql

# parse
ruby lrama/exe/lrama -d lrama/sample/parse.y -o temp/parse.c
cc -Wall temp/parse.c -I . -o temp/parse
printf "2+3*4" | temp/parse
```

## Generate Crystal parsers (this port)

```bash
# Use a local cache to avoid permission errors in sandboxed environments.
export CRYSTAL_CACHE_DIR=$PWD/.crystal-cache

# calc
crystal run src/lrama/main.cr -- samples/calc.y -o samples/calc_parser.cr
crystal build samples/calc_parser.cr -o temp/calc_parser
cat samples/calc_input.txt | temp/calc_parser

# json
crystal run src/lrama/main.cr -- samples/json.y -o samples/json_parser.cr
crystal build samples/json_parser.cr -o temp/json_parser
cat samples/json_input.txt | temp/json_parser

# sql
crystal run src/lrama/main.cr -- samples/sql.y -o samples/sql_parser.cr
crystal build samples/sql_parser.cr -o temp/sql_parser
cat samples/sql_input.sql | temp/sql_parser

# parse
crystal run src/lrama/main.cr -- samples/parse.y -o samples/parse_parser.cr
crystal build samples/parse_parser.cr -o temp/parse_parser
printf "2+3*4" | temp/parse_parser
```

## Expected outcomes

- `calc`:
  - Ruby C: prints the numeric results per line (`=> 1`, `=> 7`, `=> 9`).
  - Crystal: same output; see `samples/calc_input.txt`.

- `json`:
  - Ruby C: prints `JSON parsed successfully!` for valid input.
  - Crystal: same output for valid input; prints `Unexpected literal: ...` on invalid literals.
  - Note: the Crystal lexer regex is simplified and does not handle escaped quotes.

- `sql`:
  - Ruby C: prints a C AST with node `Type` numbers.
  - Crystal: prints a string tree (from `samples/sql.y`, same as `examples/sql.y`).
    The parse outcome is logically equivalent but the representation differs.

- `parse`:
  - Ruby C: no output by default; Crystal matches (no output on success).

## Parity gaps and improvements needed

1. **Semantic value types are limited**
   - The Crystal runtime only supports primitives (`Int32`, `String`, etc.) in
     `Lrama::Runtime::Value`.
   - The Ruby SQL sample builds a real AST (`struct ASTNode *`).
   - To match that output precisely, the Crystal runtime needs a generic
     semantic value type (e.g., `Value = Reference | ...` or a user-defined
     union type) or a generated parser class that is generic over value type.

2. **C prologue/epilogue and `%code provides` are C-specific**
   - Ruby samples embed C `#include`, `static int yylex`, and `main`.
   - Crystal ports use `%lexer` and Crystal code in the prologue instead.
   - To preserve the same text, we'd need a C-targeting generator; for
     Crystal, the equivalent is a `main` in the prologue plus `%lexer`.

3. **Error reporting differs**
   - Ruby samples use `yyerror` to print domain-specific errors.
   - Crystal currently reports success/failure based on `parse` return value
     unless the user reopens the generated parser to override `on_error`.

4. **Token value payloads**
   - The Ruby lexers populate `YYSTYPE` fields (union).
   - Crystal lexers use `int/float/string/symbol` value kinds; more complex
     token payloads (e.g., structs) would require extending `Value`.

These gaps explain why `sql` and `parse` cannot produce identical output
without further runtime and codegen enhancements.

## Parity summary (current)

- `calc`: output matches Ruby C (same results and prompt).
- `json`: output matches Ruby C for valid input; invalid literals produce the same message.
- `sql`: grammar matches, but output representation differs (Crystal prints a tree of labels, Ruby prints typed AST nodes).
- `parse`: both succeed; Ruby prints nothing; Crystal prints nothing on success.
